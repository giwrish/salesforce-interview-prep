CODING PRINCIPLES -


# [Apex Design Patterns](https://salesforcecookcode.wordpress.com/2021/02/26/apex-design-patterns/)
  - Singleton – restricts the instantiation of a class to one “single” instance only within a single transaction context.
  - Strategy – lets you define a family of algorithms, put each of them into a separate class, and make their objects interchangeable.
  - Decorator – allow you to add new functionality to an existing object without altering its structure.
  - Facade – hides the complexity of the system and provides simple interface.
  - Composite – lets you compose objects into tree structures and then work with these structures as if they were individual objects.
  - Bulk State Transition – used to perform bulk actions efficiently based on change of state of one or more records.


# [Apex Enterprise Patterns](https://www.apexhours.com/apex-enterprise-patterns/)
  - [Apex Enterprise Patterns — Separation of Concerns](https://andyinthecloud.com/2012/11/16/apex-enterprise-patterns-separation-of-concerns/)
  - [Apex Enterprise Patterns — Selector Layer](https://andyinthecloud.com/2013/09/09/apex-enterprise-patterns-selector-layer/)
  - [Apex Enterprise Patterns — Domain Layer](https://andyinthecloud.com/2013/04/24/apex-enterprise-patterns-domain-layer/)
  - [Apex Enterprise Patterns — Service Layer](https://andyinthecloud.com/2013/02/11/apex-enterprise-patterns-service-layer/)
  - [Apex Enterprise Patterns — Unit Of Work](https://andyinthecloud.com/2013/06/09/managing-your-dml-and-transactions-with-a-unit-of-work/)
  - [Apex Enterprise Patterns — Unit Of Work](https://andyinthecloud.com/2014/07/17/doing-more-work-with-the-unit-of-work/)
  - [Apex Enterprise Patterns — FinancialForce Apex Common Updates](https://andyinthecloud.com/2014/06/28/financialforce-apex-common-updates/)



# Code Review

### What do you looks for when you review the code.
The code is well-designed.
The functionality is good for the users of the code.
Any UI changes are sensible and look good.
The code isn’t more complex than it needs to be.
The developer isn’t implementing things they might need in the future but don’t know they need now.
Code has appropriate unit tests.
Tests are well-designed.
The developer used clear names for everything.
Comments are clear and useful, and mostly explain why instead of what.
Code is appropriately documented.
The code conforms to team's style guides.
